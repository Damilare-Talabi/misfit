{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, Injectable, Inject, NgModule } from '@angular/core';\n/**\n * Represents a scrolling action\n */\n\nclass PageScrollInstance {\n  /**\n   * Private constructor, requires the properties assumed to be the bare minimum.\n   * Use the factory methods to create instances:\n   *      {@link PageScrollService#create}\n   */\n  constructor(pageScrollOptions) {\n    /**\n     * These properties will be set/manipulated if the scroll animation starts\n     */\n\n    /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n    this.startScrollPosition = 0;\n    /* Whether an interrupt listener is attached to the body or not */\n\n    this.interruptListenersAttached = false;\n    /* References to the timer instance that is used to perform the scroll animation to be\n     able to clear it on animation end*/\n\n    this.timer = null;\n\n    if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {\n      pageScrollOptions.scrollViews = [pageScrollOptions.document.documentElement, pageScrollOptions.document.body, pageScrollOptions.document.body.parentNode];\n      this.isInlineScrolling = false;\n    } else {\n      this.isInlineScrolling = true;\n    }\n\n    this.pageScrollOptions = pageScrollOptions;\n  }\n\n  static getScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n    const body = pageScrollOptions.document.body;\n    const docEl = pageScrollOptions.document.documentElement;\n    const windowPageYOffset = pageScrollOptions.document.defaultView && pageScrollOptions.document.defaultView.pageYOffset || undefined;\n    const windowPageXOffset = pageScrollOptions.document.defaultView && pageScrollOptions.document.defaultView.pageXOffset || undefined;\n    const scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;\n    const scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;\n    const clientTop = docEl.clientTop || body.clientTop || 0;\n    const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n\n    if (scrollTargetElement === undefined || scrollTargetElement === null) {\n      // No element found, so return the current position to not cause any change in scroll position\n      return {\n        top: scrollTop,\n        left: scrollLeft\n      };\n    }\n\n    const box = scrollTargetElement.getBoundingClientRect();\n    const top = box.top + scrollTop - clientTop;\n    const left = box.left + scrollLeft - clientLeft;\n    return {\n      top: Math.round(top),\n      left: Math.round(left)\n    };\n  }\n\n  static getInlineScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n    const position = {\n      top: scrollTargetElement.offsetTop,\n      left: scrollTargetElement.offsetLeft\n    };\n\n    if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {\n      const accumulatedParentsPos = {\n        top: 0,\n        left: 0\n      }; // not named window to make sure we're not getting the global window variable by accident\n\n      const theWindow = scrollTargetElement.ownerDocument.defaultView;\n      let parentFound = false; // Start parent is the immediate parent\n\n      let parent = scrollTargetElement.parentElement; // Iterate upwards all parents\n\n      while (!parentFound && parent !== undefined && parent !== null) {\n        if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {\n          accumulatedParentsPos.top += parent.offsetTop;\n          accumulatedParentsPos.left += parent.offsetLeft;\n        } // Next iteration\n\n\n        parent = parent.parentElement;\n        parentFound = parent === pageScrollOptions.scrollViews[0];\n      }\n\n      if (parentFound) {\n        // Only use the results if we found the parent, otherwise we accumulated too much anyway\n        position.top += accumulatedParentsPos.top;\n        position.left += accumulatedParentsPos.left;\n      } else {\n        /* TODO Uncomment\n        if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n          console.warn('Unable to find nested scrolling targets parent!');\n        }*/\n      }\n    }\n\n    return position;\n  }\n\n  getScrollPropertyValue(scrollingView) {\n    if (!this.pageScrollOptions.verticalScrolling) {\n      return scrollingView.scrollLeft;\n    }\n\n    return scrollingView.scrollTop;\n  }\n\n  getScrollClientPropertyValue(scrollingView) {\n    if (!this.pageScrollOptions.verticalScrolling) {\n      return scrollingView.clientWidth;\n    }\n\n    return scrollingView.clientHeight;\n  }\n  /**\n   * Extract the exact location of the scrollTarget element.\n   *\n   * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n   * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n   *\n   */\n\n\n  extractScrollTargetPosition() {\n    const scrollTargetElement = this.getScrollTargetElement();\n\n    if (scrollTargetElement === null || scrollTargetElement === undefined) {\n      // Scroll target not found\n      return {\n        top: NaN,\n        left: NaN\n      };\n    }\n\n    if (this.isInlineScrolling) {\n      return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n    }\n\n    return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n  }\n  /**\n   * Get the top offset of the scroll animation.\n   * This automatically takes the offset location of the scrolling container/scrolling view\n   * into account (for nested/inline scrolling).\n   */\n\n\n  getCurrentOffset() {\n    return this.pageScrollOptions.scrollOffset;\n  }\n  /**\n   * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n   * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n   *          false if it failed for all ScrollViews, meaning that we should stop the animation\n   *          (probably because we're at the end of the scrolling region)\n   */\n\n\n  setScrollPosition(position) {\n    // Set the new scrollTop/scrollLeft to all scrollViews elements\n    return this.pageScrollOptions.scrollViews.reduce((oneAlreadyWorked, scrollingView) => {\n      const startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);\n\n      if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {\n        const scrollDistance = Math.abs(startScrollPropertyValue - position); // The movement we need to perform is less than 2px\n        // This we consider a small movement which some browser may not perform when\n        // changing the scrollTop/scrollLeft property\n        // Thus in this cases we do not stop the scroll animation, although setting the\n        // scrollTop/scrollLeft value \"fails\"\n\n        const isSmallMovement = scrollDistance < this.pageScrollOptions._minScrollDistance;\n\n        if (!this.pageScrollOptions.verticalScrolling) {\n          scrollingView.scrollLeft = position;\n        } else {\n          scrollingView.scrollTop = position;\n        } // Return true if setting the new scrollTop/scrollLeft value worked\n        // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n        // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n        // set due to dpi or rounding irregularities)\n\n\n        if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {\n          return true;\n        }\n      }\n\n      return oneAlreadyWorked;\n    }, false);\n  }\n  /**\n   * Trigger firing a animation finish event\n   * @param value Whether the animation finished at the target (true) or got interrupted (false)\n   */\n\n\n  fireEvent(value) {\n    if (this.pageScrollOptions.scrollFinishListener) {\n      this.pageScrollOptions.scrollFinishListener.emit(value);\n    }\n  }\n  /**\n   * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n   * will be called if any of the attached events is fired.\n   *\n   * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n   */\n\n\n  attachInterruptListeners(interruptReporter) {\n    if (this.interruptListenersAttached) {\n      // Detach possibly existing listeners first\n      this.detachInterruptListeners();\n    }\n\n    this.interruptListener = event => {\n      interruptReporter.report(event, this);\n    };\n\n    this.pageScrollOptions.interruptEvents.forEach(event => this.pageScrollOptions.document.body.addEventListener(event, this.interruptListener));\n    this.interruptListenersAttached = true;\n  }\n  /**\n   * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n   * interrupt\" events.\n   */\n\n\n  detachInterruptListeners() {\n    this.pageScrollOptions.interruptEvents.forEach(event => this.pageScrollOptions.document.body.removeEventListener(event, this.interruptListener));\n    this.interruptListenersAttached = false;\n  }\n\n  getScrollTargetElement() {\n    if (typeof this.pageScrollOptions.scrollTarget === 'string') {\n      const targetSelector = this.pageScrollOptions.scrollTarget;\n\n      if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n        // It's an id selector and a valid id, as it does not contain any white space characters\n        return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));\n      }\n\n      return this.pageScrollOptions.document.querySelector(targetSelector);\n    }\n\n    return this.pageScrollOptions.scrollTarget;\n  }\n\n}\n\nconst NGXPS_CONFIG = new InjectionToken('ngxps_config');\nconst defaultPageScrollConfig = {\n  _interval: 10,\n  _minScrollDistance: 2,\n  _logLevel: 1,\n  namespace: 'default',\n  verticalScrolling: true,\n  duration: 1250,\n  scrollOffset: 0,\n  advancedInlineOffsetCalculation: false,\n  interruptEvents: ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'],\n  interruptKeys: [' ', 'Escape', 'Tab', 'Enter', 'PageUp', 'PageDown', 'Home', 'End', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'],\n  interruptible: true,\n  scrollInView: true,\n  easingLogic: (t, b, c, d) => {\n    // Linear easing\n    return c * t / d + b;\n  }\n};\n\nclass PageScrollService {\n  constructor(customConfig) {\n    this.runningInstances = [];\n    this.onInterrupted = {\n      report: (event, pageScrollInstance) => {\n        if (!pageScrollInstance.pageScrollOptions.interruptible) {\n          // Non-interruptible anyway, so do not stop anything\n          return;\n        }\n\n        let shouldStop = true;\n\n        if (event.type === 'keyup') {\n          // Only stop if specific keys have been pressed, for all others don't stop anything\n          if (this.config.interruptKeys.indexOf(event.key) === -1) {\n            // The pressed key is not in the list of interrupting keys\n            shouldStop = false;\n          }\n        } else if (event.type === 'mousedown') {\n          // For mousedown events we only stop the scroll animation of the mouse has\n          // been clicked inside the scrolling container\n          if (!pageScrollInstance.pageScrollOptions.scrollViews.some(scrollingView => scrollingView.contains(event.target))) {\n            // Mouse clicked an element which is not inside any of the the scrolling containers\n            shouldStop = false;\n          }\n        }\n\n        if (shouldStop) {\n          this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n        }\n      }\n    };\n    this.config = Object.assign(Object.assign({}, defaultPageScrollConfig), customConfig);\n  }\n\n  stopInternal(interrupted, pageScrollInstance) {\n    const index = this.runningInstances.indexOf(pageScrollInstance);\n\n    if (index >= 0) {\n      this.runningInstances.splice(index, 1);\n    }\n\n    if (pageScrollInstance.interruptListenersAttached) {\n      pageScrollInstance.detachInterruptListeners();\n    }\n\n    if (pageScrollInstance.timer) {\n      // Clear/Stop the timer\n      clearInterval(pageScrollInstance.timer); // Clear the reference to this timer\n\n      pageScrollInstance.timer = undefined;\n      pageScrollInstance.fireEvent(!interrupted);\n      return true;\n    }\n\n    return false;\n  }\n\n  create(options) {\n    return new PageScrollInstance(Object.assign(Object.assign({}, this.config), options));\n  }\n  /**\n   * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n   *\n   * This is the core functionality of the whole library.\n   */\n  // tslint:disable-next-line:cyclomatic-complexity\n\n\n  start(pageScrollInstance) {\n    // Merge the default options in the pageScrollInstance options\n    pageScrollInstance.pageScrollOptions = Object.assign(Object.assign({}, this.config), pageScrollInstance.pageScrollOptions); // Stop all possibly running scroll animations in the same namespace\n\n    this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n\n    if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {\n      // No scrollViews specified, thus we can't animate anything\n      if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n        console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');\n      }\n\n      return;\n    }\n\n    let startScrollPositionFound = false;\n    let scrollRange = pageScrollInstance.getScrollClientPropertyValue(pageScrollInstance.pageScrollOptions.scrollViews[0]); // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next\n\n    pageScrollInstance.startScrollPosition = 0; // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)\n\n    pageScrollInstance.pageScrollOptions.scrollViews.forEach(scrollingView => {\n      if (scrollingView === undefined || scrollingView === null) {\n        return;\n      } // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n      // or \"scrollLeft\" property that is not undefined and unequal to 0\n\n\n      const scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n\n      if (!startScrollPositionFound && scrollPosition) {\n        // We found a scrollingView that does not have scrollTop or scrollLeft 0\n        // Return the scroll position value, as this will be our startScrollPosition\n        pageScrollInstance.startScrollPosition = scrollPosition;\n        startScrollPositionFound = true; // Remember te scrollRange of this scrollingView\n\n        scrollRange = pageScrollInstance.getScrollClientPropertyValue(scrollingView);\n      }\n    });\n    const pageScrollOffset = pageScrollInstance.getCurrentOffset(); // Calculate the target position that the scroll animation should go to\n\n    const scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n    pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset); // Calculate the distance we need to go in total\n\n    pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n\n    if (isNaN(pageScrollInstance.distanceToScroll)) {\n      // We weren't able to find the target position, maybe the element does not exist?\n      if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n        console.log('Scrolling not possible, as we can\\'t find the specified target');\n      }\n\n      pageScrollInstance.fireEvent(false);\n      return;\n    } // We're at the final destination already\n    // OR we need to scroll down but are already at the end\n    // OR we need to scroll up but are at the top already\n\n\n    const allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance; // Check how long we need to scroll if a speed option is given\n    // Default executionDuration is the specified duration\n\n\n    pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration; // Maybe we need to pay attention to the speed option?\n\n    if (pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null && (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {\n      // Speed option is set and no duration => calculate duration based on speed and scroll distance\n      pageScrollInstance.executionDuration = Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;\n    } // We should go there directly, as our \"animation\" would have one big step\n    // only anyway and this way we save the interval stuff\n\n\n    const tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;\n\n    if (allReadyAtDestination || tooShortInterval) {\n      if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n        if (allReadyAtDestination) {\n          console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n        } else {\n          console.log('Scroll duration shorter that interval length, jumping to target');\n        }\n      }\n\n      pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n      pageScrollInstance.fireEvent(true);\n      return;\n    }\n\n    if (!pageScrollInstance.pageScrollOptions.scrollInView) {\n      const alreadyInView = pageScrollInstance.targetScrollPosition > pageScrollInstance.startScrollPosition && pageScrollInstance.targetScrollPosition <= pageScrollInstance.startScrollPosition + scrollRange;\n\n      if (alreadyInView) {\n        if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n          console.log('Not scrolling, as target already in view');\n        }\n\n        pageScrollInstance.fireEvent(true);\n        return;\n      }\n    } // Register the interrupt listeners if we want an interruptible scroll animation\n\n\n    if (pageScrollInstance.pageScrollOptions.interruptible) {\n      pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n    } // Let's get started, get the start time...\n\n\n    pageScrollInstance.startTime = new Date().getTime(); // .. and calculate the end time (when we need to finish at last)\n\n    pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n    pageScrollInstance.timer = setInterval(instance => {\n      // Take the current time\n      const currentTime = new Date().getTime(); // Determine the new scroll position\n\n      let newScrollPosition;\n      let stopNow = false;\n\n      if (instance.endTime <= currentTime) {\n        // We're over the time already, so go the targetScrollPosition (aka destination)\n        newScrollPosition = instance.targetScrollPosition;\n        stopNow = true;\n      } else {\n        // Calculate the scroll position based on the current time using the easing function\n        newScrollPosition = Math.round(instance.pageScrollOptions.easingLogic(currentTime - instance.startTime, instance.startScrollPosition, instance.distanceToScroll, instance.executionDuration));\n      }\n\n      if (this.config._logLevel >= 5 && isDevMode()) {\n        console.warn('Scroll Position: ' + newScrollPosition);\n      } // Set the new scrollPosition to all scrollViews elements\n\n\n      if (!instance.setScrollPosition(newScrollPosition)) {\n        // Setting the new scrollTop/scrollLeft value failed for all ScrollViews\n        // early stop the scroll animation to save resources\n        stopNow = true;\n      } // At the end do the internal stop maintenance and fire the pageScrollFinish event\n      // (otherwise the event might arrive at \"too early\")\n\n\n      if (stopNow) {\n        this.stopInternal(false, instance);\n      }\n    }, this.config._interval, pageScrollInstance); // Register the instance as running one\n\n    this.runningInstances.push(pageScrollInstance);\n  }\n\n  scroll(options) {\n    this.start(this.create(options));\n  }\n  /**\n   * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n   */\n\n\n  stopAll(namespace) {\n    if (this.runningInstances.length > 0) {\n      let stoppedSome = false;\n\n      for (let i = 0; i < this.runningInstances.length; ++i) {\n        const pageScrollInstance = this.runningInstances[i];\n\n        if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {\n          stoppedSome = true;\n          this.stopInternal(true, pageScrollInstance); // Decrease the counter, as we removed an item from the array we iterate over\n\n          i--;\n        }\n      }\n\n      return stoppedSome;\n    }\n\n    return false;\n  }\n\n  stop(pageScrollInstance) {\n    return this.stopInternal(true, pageScrollInstance);\n  }\n\n}\n\nPageScrollService.ɵfac = function PageScrollService_Factory(t) {\n  return new (t || PageScrollService)(i0.ɵɵinject(NGXPS_CONFIG));\n};\n\nPageScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PageScrollService,\n  factory: PageScrollService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PageScrollService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXPS_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\nclass NgxPageScrollCoreModule {\n  static forRoot(config) {\n    return {\n      ngModule: NgxPageScrollCoreModule,\n      providers: [PageScrollService, {\n        provide: NGXPS_CONFIG,\n        useValue: config\n      }]\n    };\n  }\n\n}\n\nNgxPageScrollCoreModule.ɵfac = function NgxPageScrollCoreModule_Factory(t) {\n  return new (t || NgxPageScrollCoreModule)();\n};\n\nNgxPageScrollCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPageScrollCoreModule\n});\nNgxPageScrollCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [PageScrollService, {\n    provide: NGXPS_CONFIG,\n    useValue: {}\n  }]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPageScrollCoreModule, [{\n    type: NgModule,\n    args: [{\n      providers: [PageScrollService, {\n        provide: NGXPS_CONFIG,\n        useValue: {}\n      }]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of ngx-page-scroll-core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NGXPS_CONFIG, NgxPageScrollCoreModule, PageScrollInstance, PageScrollService, defaultPageScrollConfig };","map":{"version":3,"sources":["C:/Users/user/Desktop/learning projects/misfits/node_modules/ngx-page-scroll-core/fesm2015/ngx-page-scroll-core.mjs"],"names":["i0","InjectionToken","isDevMode","Injectable","Inject","NgModule","PageScrollInstance","constructor","pageScrollOptions","startScrollPosition","interruptListenersAttached","timer","scrollViews","length","document","documentElement","body","parentNode","isInlineScrolling","getScrollingTargetPosition","scrollTargetElement","docEl","windowPageYOffset","defaultView","pageYOffset","undefined","windowPageXOffset","pageXOffset","scrollTop","scrollLeft","clientTop","clientLeft","top","left","box","getBoundingClientRect","Math","round","getInlineScrollingTargetPosition","position","offsetTop","offsetLeft","advancedInlineOffsetCalculation","accumulatedParentsPos","theWindow","ownerDocument","parentFound","parent","parentElement","getComputedStyle","getPropertyValue","getScrollPropertyValue","scrollingView","verticalScrolling","getScrollClientPropertyValue","clientWidth","clientHeight","extractScrollTargetPosition","getScrollTargetElement","NaN","getCurrentOffset","scrollOffset","setScrollPosition","reduce","oneAlreadyWorked","startScrollPropertyValue","scrollDistance","abs","isSmallMovement","_minScrollDistance","fireEvent","value","scrollFinishListener","emit","attachInterruptListeners","interruptReporter","detachInterruptListeners","interruptListener","event","report","interruptEvents","forEach","addEventListener","removeEventListener","scrollTarget","targetSelector","match","getElementById","substr","querySelector","NGXPS_CONFIG","defaultPageScrollConfig","_interval","_logLevel","namespace","duration","interruptKeys","interruptible","scrollInView","easingLogic","t","b","c","d","PageScrollService","customConfig","runningInstances","onInterrupted","pageScrollInstance","shouldStop","type","config","indexOf","key","some","contains","target","stopAll","Object","assign","stopInternal","interrupted","index","splice","clearInterval","create","options","start","console","warn","startScrollPositionFound","scrollRange","scrollPosition","pageScrollOffset","scrollTargetPosition","targetScrollPosition","distanceToScroll","isNaN","log","allReadyAtDestination","executionDuration","speed","tooShortInterval","alreadyInView","startTime","Date","getTime","endTime","setInterval","instance","currentTime","newScrollPosition","stopNow","push","scroll","stoppedSome","i","stop","ɵfac","ɵprov","args","providedIn","decorators","NgxPageScrollCoreModule","forRoot","ngModule","providers","provide","useValue","ɵmod","ɵinj"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, Injectable, Inject, NgModule } from '@angular/core';\n\n/**\n * Represents a scrolling action\n */\nclass PageScrollInstance {\n    /**\n     * Private constructor, requires the properties assumed to be the bare minimum.\n     * Use the factory methods to create instances:\n     *      {@link PageScrollService#create}\n     */\n    constructor(pageScrollOptions) {\n        /**\n         * These properties will be set/manipulated if the scroll animation starts\n         */\n        /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n        this.startScrollPosition = 0;\n        /* Whether an interrupt listener is attached to the body or not */\n        this.interruptListenersAttached = false;\n        /* References to the timer instance that is used to perform the scroll animation to be\n         able to clear it on animation end*/\n        this.timer = null;\n        if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {\n            pageScrollOptions.scrollViews = [\n                pageScrollOptions.document.documentElement,\n                pageScrollOptions.document.body,\n                pageScrollOptions.document.body.parentNode,\n            ];\n            this.isInlineScrolling = false;\n        }\n        else {\n            this.isInlineScrolling = true;\n        }\n        this.pageScrollOptions = pageScrollOptions;\n    }\n    static getScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const body = pageScrollOptions.document.body;\n        const docEl = pageScrollOptions.document.documentElement;\n        const windowPageYOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageYOffset || undefined;\n        const windowPageXOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageXOffset || undefined;\n        const scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;\n        const scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;\n        const clientTop = docEl.clientTop || body.clientTop || 0;\n        const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n        if (scrollTargetElement === undefined || scrollTargetElement === null) {\n            // No element found, so return the current position to not cause any change in scroll position\n            return { top: scrollTop, left: scrollLeft };\n        }\n        const box = scrollTargetElement.getBoundingClientRect();\n        const top = box.top + scrollTop - clientTop;\n        const left = box.left + scrollLeft - clientLeft;\n        return { top: Math.round(top), left: Math.round(left) };\n    }\n    static getInlineScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };\n        if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {\n            const accumulatedParentsPos = { top: 0, left: 0 };\n            // not named window to make sure we're not getting the global window variable by accident\n            const theWindow = scrollTargetElement.ownerDocument.defaultView;\n            let parentFound = false;\n            // Start parent is the immediate parent\n            let parent = scrollTargetElement.parentElement;\n            // Iterate upwards all parents\n            while (!parentFound && parent !== undefined && parent !== null) {\n                if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {\n                    accumulatedParentsPos.top += parent.offsetTop;\n                    accumulatedParentsPos.left += parent.offsetLeft;\n                }\n                // Next iteration\n                parent = parent.parentElement;\n                parentFound = parent === pageScrollOptions.scrollViews[0];\n            }\n            if (parentFound) {\n                // Only use the results if we found the parent, otherwise we accumulated too much anyway\n                position.top += accumulatedParentsPos.top;\n                position.left += accumulatedParentsPos.left;\n            }\n            else {\n                /* TODO Uncomment\n                if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                  console.warn('Unable to find nested scrolling targets parent!');\n                }*/\n            }\n        }\n        return position;\n    }\n    getScrollPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.scrollLeft;\n        }\n        return scrollingView.scrollTop;\n    }\n    getScrollClientPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.clientWidth;\n        }\n        return scrollingView.clientHeight;\n    }\n    /**\n     * Extract the exact location of the scrollTarget element.\n     *\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n     *\n     */\n    extractScrollTargetPosition() {\n        const scrollTargetElement = this.getScrollTargetElement();\n        if (scrollTargetElement === null || scrollTargetElement === undefined) {\n            // Scroll target not found\n            return { top: NaN, left: NaN };\n        }\n        if (this.isInlineScrolling) {\n            return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n        }\n        return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n    }\n    /**\n     * Get the top offset of the scroll animation.\n     * This automatically takes the offset location of the scrolling container/scrolling view\n     * into account (for nested/inline scrolling).\n     */\n    getCurrentOffset() {\n        return this.pageScrollOptions.scrollOffset;\n    }\n    /**\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n     *          false if it failed for all ScrollViews, meaning that we should stop the animation\n     *          (probably because we're at the end of the scrolling region)\n     */\n    setScrollPosition(position) {\n        // Set the new scrollTop/scrollLeft to all scrollViews elements\n        return this.pageScrollOptions.scrollViews.reduce((oneAlreadyWorked, scrollingView) => {\n            const startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);\n            if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {\n                const scrollDistance = Math.abs(startScrollPropertyValue - position);\n                // The movement we need to perform is less than 2px\n                // This we consider a small movement which some browser may not perform when\n                // changing the scrollTop/scrollLeft property\n                // Thus in this cases we do not stop the scroll animation, although setting the\n                // scrollTop/scrollLeft value \"fails\"\n                const isSmallMovement = scrollDistance < this.pageScrollOptions._minScrollDistance;\n                if (!this.pageScrollOptions.verticalScrolling) {\n                    scrollingView.scrollLeft = position;\n                }\n                else {\n                    scrollingView.scrollTop = position;\n                }\n                // Return true if setting the new scrollTop/scrollLeft value worked\n                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n                // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n                // set due to dpi or rounding irregularities)\n                if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {\n                    return true;\n                }\n            }\n            return oneAlreadyWorked;\n        }, false);\n    }\n    /**\n     * Trigger firing a animation finish event\n     * @param value Whether the animation finished at the target (true) or got interrupted (false)\n     */\n    fireEvent(value) {\n        if (this.pageScrollOptions.scrollFinishListener) {\n            this.pageScrollOptions.scrollFinishListener.emit(value);\n        }\n    }\n    /**\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n     * will be called if any of the attached events is fired.\n     *\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n     */\n    attachInterruptListeners(interruptReporter) {\n        if (this.interruptListenersAttached) {\n            // Detach possibly existing listeners first\n            this.detachInterruptListeners();\n        }\n        this.interruptListener = (event) => {\n            interruptReporter.report(event, this);\n        };\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.addEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = true;\n    }\n    /**\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n     * interrupt\" events.\n     */\n    detachInterruptListeners() {\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.removeEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = false;\n    }\n    getScrollTargetElement() {\n        if (typeof this.pageScrollOptions.scrollTarget === 'string') {\n            const targetSelector = this.pageScrollOptions.scrollTarget;\n            if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n                // It's an id selector and a valid id, as it does not contain any white space characters\n                return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));\n            }\n            return this.pageScrollOptions.document.querySelector(targetSelector);\n        }\n        return this.pageScrollOptions.scrollTarget;\n    }\n}\n\nconst NGXPS_CONFIG = new InjectionToken('ngxps_config');\nconst defaultPageScrollConfig = {\n    _interval: 10,\n    _minScrollDistance: 2,\n    _logLevel: 1,\n    namespace: 'default',\n    verticalScrolling: true,\n    duration: 1250,\n    scrollOffset: 0,\n    advancedInlineOffsetCalculation: false,\n    interruptEvents: ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'],\n    interruptKeys: [' ', 'Escape', 'Tab', 'Enter', 'PageUp', 'PageDown', 'Home', 'End', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'],\n    interruptible: true,\n    scrollInView: true,\n    easingLogic: (t, b, c, d) => {\n        // Linear easing\n        return c * t / d + b;\n    },\n};\n\nclass PageScrollService {\n    constructor(customConfig) {\n        this.runningInstances = [];\n        this.onInterrupted = {\n            report: (event, pageScrollInstance) => {\n                if (!pageScrollInstance.pageScrollOptions.interruptible) {\n                    // Non-interruptible anyway, so do not stop anything\n                    return;\n                }\n                let shouldStop = true;\n                if (event.type === 'keyup') {\n                    // Only stop if specific keys have been pressed, for all others don't stop anything\n                    if (this.config.interruptKeys.indexOf(event.key) === -1) {\n                        // The pressed key is not in the list of interrupting keys\n                        shouldStop = false;\n                    }\n                }\n                else if (event.type === 'mousedown') {\n                    // For mousedown events we only stop the scroll animation of the mouse has\n                    // been clicked inside the scrolling container\n                    if (!pageScrollInstance.pageScrollOptions.scrollViews.some(scrollingView => scrollingView.contains(event.target))) {\n                        // Mouse clicked an element which is not inside any of the the scrolling containers\n                        shouldStop = false;\n                    }\n                }\n                if (shouldStop) {\n                    this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n                }\n            },\n        };\n        this.config = Object.assign(Object.assign({}, defaultPageScrollConfig), customConfig);\n    }\n    stopInternal(interrupted, pageScrollInstance) {\n        const index = this.runningInstances.indexOf(pageScrollInstance);\n        if (index >= 0) {\n            this.runningInstances.splice(index, 1);\n        }\n        if (pageScrollInstance.interruptListenersAttached) {\n            pageScrollInstance.detachInterruptListeners();\n        }\n        if (pageScrollInstance.timer) {\n            // Clear/Stop the timer\n            clearInterval(pageScrollInstance.timer);\n            // Clear the reference to this timer\n            pageScrollInstance.timer = undefined;\n            pageScrollInstance.fireEvent(!interrupted);\n            return true;\n        }\n        return false;\n    }\n    create(options) {\n        return new PageScrollInstance(Object.assign(Object.assign({}, this.config), options));\n    }\n    /**\n     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n     *\n     * This is the core functionality of the whole library.\n     */\n    // tslint:disable-next-line:cyclomatic-complexity\n    start(pageScrollInstance) {\n        // Merge the default options in the pageScrollInstance options\n        pageScrollInstance.pageScrollOptions = Object.assign(Object.assign({}, this.config), pageScrollInstance.pageScrollOptions);\n        // Stop all possibly running scroll animations in the same namespace\n        this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n        if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {\n            // No scrollViews specified, thus we can't animate anything\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');\n            }\n            return;\n        }\n        let startScrollPositionFound = false;\n        let scrollRange = pageScrollInstance.getScrollClientPropertyValue(pageScrollInstance.pageScrollOptions.scrollViews[0]);\n        // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next\n        pageScrollInstance.startScrollPosition = 0;\n        // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)\n        pageScrollInstance.pageScrollOptions.scrollViews.forEach(scrollingView => {\n            if (scrollingView === undefined || scrollingView === null) {\n                return;\n            }\n            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n            // or \"scrollLeft\" property that is not undefined and unequal to 0\n            const scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n            if (!startScrollPositionFound && scrollPosition) {\n                // We found a scrollingView that does not have scrollTop or scrollLeft 0\n                // Return the scroll position value, as this will be our startScrollPosition\n                pageScrollInstance.startScrollPosition = scrollPosition;\n                startScrollPositionFound = true;\n                // Remember te scrollRange of this scrollingView\n                scrollRange = pageScrollInstance.getScrollClientPropertyValue(scrollingView);\n            }\n        });\n        const pageScrollOffset = pageScrollInstance.getCurrentOffset();\n        // Calculate the target position that the scroll animation should go to\n        const scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);\n        // Calculate the distance we need to go in total\n        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n        if (isNaN(pageScrollInstance.distanceToScroll)) {\n            // We weren't able to find the target position, maybe the element does not exist?\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.log('Scrolling not possible, as we can\\'t find the specified target');\n            }\n            pageScrollInstance.fireEvent(false);\n            return;\n        }\n        // We're at the final destination already\n        // OR we need to scroll down but are already at the end\n        // OR we need to scroll up but are at the top already\n        const allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance;\n        // Check how long we need to scroll if a speed option is given\n        // Default executionDuration is the specified duration\n        pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration;\n        // Maybe we need to pay attention to the speed option?\n        if ((pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null) &&\n            (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {\n            // Speed option is set and no duration => calculate duration based on speed and scroll distance\n            pageScrollInstance.executionDuration =\n                Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;\n        }\n        // We should go there directly, as our \"animation\" would have one big step\n        // only anyway and this way we save the interval stuff\n        const tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;\n        if (allReadyAtDestination || tooShortInterval) {\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                if (allReadyAtDestination) {\n                    console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n                }\n                else {\n                    console.log('Scroll duration shorter that interval length, jumping to target');\n                }\n            }\n            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n            pageScrollInstance.fireEvent(true);\n            return;\n        }\n        if (!pageScrollInstance.pageScrollOptions.scrollInView) {\n            const alreadyInView = pageScrollInstance.targetScrollPosition > pageScrollInstance.startScrollPosition &&\n                pageScrollInstance.targetScrollPosition <= pageScrollInstance.startScrollPosition + scrollRange;\n            if (alreadyInView) {\n                if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                    console.log('Not scrolling, as target already in view');\n                }\n                pageScrollInstance.fireEvent(true);\n                return;\n            }\n        }\n        // Register the interrupt listeners if we want an interruptible scroll animation\n        if (pageScrollInstance.pageScrollOptions.interruptible) {\n            pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n        }\n        // Let's get started, get the start time...\n        pageScrollInstance.startTime = new Date().getTime();\n        // .. and calculate the end time (when we need to finish at last)\n        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n        pageScrollInstance.timer = setInterval((instance) => {\n            // Take the current time\n            const currentTime = new Date().getTime();\n            // Determine the new scroll position\n            let newScrollPosition;\n            let stopNow = false;\n            if (instance.endTime <= currentTime) {\n                // We're over the time already, so go the targetScrollPosition (aka destination)\n                newScrollPosition = instance.targetScrollPosition;\n                stopNow = true;\n            }\n            else {\n                // Calculate the scroll position based on the current time using the easing function\n                newScrollPosition = Math.round(instance.pageScrollOptions.easingLogic(currentTime - instance.startTime, instance.startScrollPosition, instance.distanceToScroll, instance.executionDuration));\n            }\n            if (this.config._logLevel >= 5 && isDevMode()) {\n                console.warn('Scroll Position: ' + newScrollPosition);\n            }\n            // Set the new scrollPosition to all scrollViews elements\n            if (!instance.setScrollPosition(newScrollPosition)) {\n                // Setting the new scrollTop/scrollLeft value failed for all ScrollViews\n                // early stop the scroll animation to save resources\n                stopNow = true;\n            }\n            // At the end do the internal stop maintenance and fire the pageScrollFinish event\n            // (otherwise the event might arrive at \"too early\")\n            if (stopNow) {\n                this.stopInternal(false, instance);\n            }\n        }, this.config._interval, pageScrollInstance);\n        // Register the instance as running one\n        this.runningInstances.push(pageScrollInstance);\n    }\n    scroll(options) {\n        this.start(this.create(options));\n    }\n    /**\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n     */\n    stopAll(namespace) {\n        if (this.runningInstances.length > 0) {\n            let stoppedSome = false;\n            for (let i = 0; i < this.runningInstances.length; ++i) {\n                const pageScrollInstance = this.runningInstances[i];\n                if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {\n                    stoppedSome = true;\n                    this.stopInternal(true, pageScrollInstance);\n                    // Decrease the counter, as we removed an item from the array we iterate over\n                    i--;\n                }\n            }\n            return stoppedSome;\n        }\n        return false;\n    }\n    stop(pageScrollInstance) {\n        return this.stopInternal(true, pageScrollInstance);\n    }\n}\nPageScrollService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: PageScrollService, deps: [{ token: NGXPS_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\nPageScrollService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: PageScrollService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: PageScrollService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [NGXPS_CONFIG]\n                    }] }];\n    } });\n\nclass NgxPageScrollCoreModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgxPageScrollCoreModule,\n            providers: [PageScrollService, { provide: NGXPS_CONFIG, useValue: config }],\n        };\n    }\n}\nNgxPageScrollCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: NgxPageScrollCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPageScrollCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: NgxPageScrollCoreModule });\nNgxPageScrollCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: NgxPageScrollCoreModule, providers: [\n        PageScrollService,\n        { provide: NGXPS_CONFIG, useValue: {} },\n    ] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: NgxPageScrollCoreModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [\n                        PageScrollService,\n                        { provide: NGXPS_CONFIG, useValue: {} },\n                    ],\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-page-scroll-core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGXPS_CONFIG, NgxPageScrollCoreModule, PageScrollInstance, PageScrollService, defaultPageScrollConfig };\n"]},"metadata":{},"sourceType":"module"}